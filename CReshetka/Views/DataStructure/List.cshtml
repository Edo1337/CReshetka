@{
    ViewData["Title"] = "Список (List)";
}
<h1>@ViewData["Title"]</h1>

<div class="container">
    <div>
        <p>
            <span>Список, или же @("List<T>()")</span> - это универсальный класс в .NET, который представляет собой упорядоченный набор объектов. Он реализует интерфейс @("IList<T>()"), который предоставляет методы для поиска, сортировки и управления списком.
        </p>
        <p>
            <h3><span>Важные особенностей @("List<T>()")</span></h3>
        <p>
            Упорядоченный набор элементов: Элементы в @("List<T>()") хранятся в определенном порядке, и каждый элемент имеет индекс, определяющий его позицию в списке.
        </p>
        <p>
            Доступ по индексу: Элементы в @("List<T>()") можно получить или задать по их индексу, используя квадратные скобки. Индексы начинаются с 0.
        </p>
        <p>
            Разрешение и расширение: @("List<T>()") может динамически изменять свой размер, чтобы удовлетворить потребности хранения. Если вы добавляете элементы в список, он автоматически расширяется, чтобы вместить новые элементы.
        </p>
        <p>
            Поиск и сортировка: @("List<T>()") предоставляет методы для поиска элементов (например, IndexOf, Find, FindAll) и для сортировки списка (например, Sort).
        </p>
        <p>
            Вставка и удаление: Вы можете вставлять или удалять элементы в любой позиции списка, используя методы Insert, Remove, RemoveAt.
        </p>
        <p>
            Производительность: @("List<T>()") обеспечивает хорошую производительность для доступа к элементам по индексу, но вставка или удаление элементов может быть медленной, так как требует перемещения элементов.
        </p>
        <p>
            Поддержка LINQ: @("List<T>()") реализует интерфейс @("IEnumerable<T>"), что позволяет использовать LINQ (Language Integrated Query) для выполнения запросов и преобразований данных.
        </p>
        <p>
            Поддержка сериализации: @("List<T>()") поддерживает сериализацию и десериализацию, что позволяет сохранять и восстанавливать списки между разными сеансами приложения.
        </p>
        <p>
            Потокобезопасность: @("List<T>()") не является потокобезопасным. Если вы работаете с @("List<T>()") из нескольких потоков одновременно, вам может потребоваться использовать потокобезопасные версии, такие как @("ConcurrentBag<T>"), @("ConcurrentQueue<T>"), @("ConcurrentStack<T>") или @("ConcurrentDictionary<TKey, TValue>").
        </p>
        <h3><span>Пример использования @("List<T>"):</span></h3>
        <pre><code>
List<int> numbers = new List<int>();
numbers.Add(10);
numbers.Add(20);
numbers.Add(30);

int firstNumber = numbers[0]; // Получаем первый элемент
numbers.RemoveAt(1); // Удаляем второй элемент

bool containsNumber = numbers.Contains(20); // Проверяем, содержит ли список число 20

numbers.Sort(); // Сортируем список

foreach (int number in numbers)
{
    Console.WriteLine(number);
}
        </pre></code>
        <p>
            В этом примере мы создаем список целых чисел, добавляем в него несколько элементов, получаем доступ к элементам по индексу, удаляем элемент, проверяем наличие элемента в списке и сортируем список.
        </p>
        <p>
            <h3><span>Объяснение от <a href="https://www.youtube.com/codaza-channel">Codaza</a>:</span></h3>
        </p>
        <div style="align-content:center">
            <iframe width="1280" height="720" src="https://www.youtube.com/embed/DcqXjL8U7wY" title="C# List" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
    </div>
</div>