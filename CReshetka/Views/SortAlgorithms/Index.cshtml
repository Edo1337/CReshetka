@{
    ViewData["Title"] = "Алгоритмы сортировки";
}
<h1>@ViewData["Title"]</h1>

<div class="conteiner">
    <p>
        <span>Алгоритмы</span> — это изюминка программирования! Они представляют собой процессы или наборы инструкций, которые решают определенную задачу.
        В этом разделе мы рассмотрим различные алгоритмы с использованием языка программирования C#. Будем исследовать их основные принципы, реализацию и применение.
    <p>
    <p>
        <h3><span>Big O</span></h3>
        <span>Big O</span> - это термин, используемый для оценки верхней границы (наихудшего случая), временной сложности алгоритма.
        Простыми словами Big O показывает как будет меняться производительность алгоритма с зависимости от роста входящих данных.
        Если мы будем увеличивать количество входящих данных, то у нас может расти количество операций и время за которое выполнится алгоритм. Так же может расти количество памяти используемой данным алгоритмом для обработки входного объема данных. Big O будет показывать скорость роста времени исполнения алгоритма.
    </p>
    <p>
        <h3><span>Примеры сложностей Big O:</span></h3>
    <p>
        <span>O(1)</span>: Константная сложность. Время выполнения алгоритма не зависит от размера входных данных. Например, доступ к элементу массива по индексу.
    </p>
    <p>
        <span>O(log n)</span>: Логарифмическая сложность. Время выполнения алгоритма растет медленно с увеличением размера входных данных. Например, бинарный поиск в отсортированном массиве.
        Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам.
        Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину.
        И так будем продолжать делить пополам, в итоге проверим log n элементов.
    </p>
    <p>
        <span>O(n)</span>: Линейная сложность. Время выполнения алгоритма пропорционально размеру входных данных. Например, просмотр всех элементов в массиве,
        или же алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.
    </p>
    <p>
        <span>O(n log n)</span>: Линейно-логарифмическая сложность. Время выполнения алгоритма растет быстрее, чем линейно, но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).
    </p>
    <p>
        <span>O(n^2)</span>: Квадратичная сложность. Время выполнения алгоритма зависит от квадрата размера входных данных. Например, сортировка пузырьком (bubble sort).
    </p>
    <p>
        <span>O(n^3)</span>: Кубическая сложность. Время выполнения алгоритма зависит от размера входных данных в кубе. Например, алгоритмы, которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.
    </p>
    <p>
        <span>O(n!)</span>: Факториальная сложность. Это самая высокая степень роста времени выполнения алгоритма. Время выполнения алгоритма растет факториально от размера входных данных. Этот тип сложности встречается, например, при переборе всех возможных комбинаций элементов, что делает его чрезвычайно неэффективным для больших значений n.
    </p>
    <h3><span>Определение</span></h3>
    <p>
        <span>Алгоритмы сортировки — это набор инструкций, которые принимают массив или список в качестве входных данных и упорядочивают элементы в определенном порядке.</span>
        Сортировка чаще всего осуществляется в числовом или алфавитном (или лексикографическом) порядке и может осуществляться по возрастанию (AZ, 0–9) или по убыванию (ZA, 9–0).
    </p>
    <h3><span>Почему алгоритмы сортировки важны</span></h3>
    <p>
        Поскольку алгоритмы сортировки часто могут снизить сложность проблемы, они очень важны в информатике. Эти алгоритмы имеют прямое применение в алгоритмах поиска, алгоритмах баз данных, методах «разделяй и властвуй», алгоритмах структур данных и многом другом.
        Вы готовы к погружению в алгоритмические просторы? Тогда давайте начнем!
    </p>
    <h3><span>Компромиссы алгоритмов сортировки</span></h3>
    <P>
        При выборе алгоритма сортировки необходимо задать несколько вопросов: насколько велика сортируемая коллекция? Сколько памяти доступно? Нужно ли расширять коллекцию?
        Ответы на эти вопросы могут определить, какой алгоритм будет работать лучше всего в каждой ситуации. Некоторым алгоритмам, таким как сортировка слиянием, может потребоваться много места или памяти для работы, тогда как сортировка вставкой не всегда самая быстрая, но для запуска не требуется много ресурсов.
        Прежде чем решить, какой алгоритм сортировки использовать, вам следует определить свои требования и принять во внимание ограничения вашей системы.
    </P>
</div>
